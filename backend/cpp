package main

import (
	"database/sql"
	"fmt"
	"log"
	"net/http"
	"strings"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"

	_ "github.com/go-sql-driver/mysql"
)

// Product represents the structure of a product in the database
type Product struct {
	ID           int     `json:"id"`
	Name         string  `json:"name"`
	Description  string  `json:"description"`
	Price        float64 `json:"price"`
	Quantity     int     `json:"quantity"`
	IsActive     bool    `json:"is_active"`
	ImageURL     string  `json:"image_url"`
	Discontinued bool    `json:"discontinued"`
}

// LoginRequest represents the incoming login request structure
type LoginRequest struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

// LoginResponse represents the outgoing response after a login attempt
type LoginResponse struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
	Name    string `json:"name,omitempty"`
	Role    string `json:"role,omitempty"`
}

// OrderItem represents a product item in an order
type OrderItem struct {
	ProductID   int     `json:"productId"`
	ProductName string  `json:"productName"`
	Quantity    int     `json:"quantity"`
	Price       float64 `json:"priceAtPurchase"`
}

// Order represents an order with its items
type Order struct {
	ID           int         `json:"id"`
	CustomerName string      `json:"customerName"`
	Total        float64     `json:"total"`
	Status       string      `json:"status"`
	Date         string      `json:"date"`
	Items        []OrderItem `json:"items"`
	DiscountCode string      `json:"discountCode,omitempty"`
}

// Discount represents a discount code with its percentage
type Discount struct {
	Code   string  `json:"code"`
	Amount float64 `json:"amount"`
}

// Global variable for MySQL DB connection
var db *sql.DB

func init() {
	var err error
	dsn := "root:Jfyetdhfyd@tcp(127.0.0.1:3306)/backend"
	db, err = sql.Open("mysql", dsn)
	if err != nil {
		log.Fatal("Error connecting to the database:", err)
	}
	if err = db.Ping(); err != nil {
		log.Fatal("Error pinging the database:", err)
	}
}

// checkCredentials compares the provided email and password with the database
func checkCredentials(email, password string) (string, string, bool, error) {
	var dbPassword, dbName, dbRole string

	err := db.QueryRow("SELECT password, name, role FROM accounts WHERE email = ?", email).Scan(&dbPassword, &dbName, &dbRole)
	if err != nil {
		if err == sql.ErrNoRows {
			return "", "", false, fmt.Errorf("no user found with that email")
		}
		return "", "", false, err
	}

	if dbPassword != password {
		return "", "", false, fmt.Errorf("incorrect password")
	}

	return dbName, dbRole, true, nil
}

func loginHandler(c *gin.Context) {
	var req LoginRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, LoginResponse{
			Success: false,
			Message: "Invalid request body",
		})
		return
	}

	name, role, isValid, err := checkCredentials(req.Email, req.Password)
	if err != nil {
		c.JSON(http.StatusUnauthorized, LoginResponse{
			Success: false,
			Message: err.Error(),
		})
		return
	}

	if !isValid {
		c.JSON(http.StatusUnauthorized, LoginResponse{
			Success: false,
			Message: "Invalid credentials",
		})
		return
	}

	c.JSON(http.StatusOK, LoginResponse{
		Success: true,
		Message: "Login successful!",
		Name:    name,
		Role:    role,
	})
}

func getProductsHandler(c *gin.Context) {
	rows, err := db.Query("SELECT id, name, description, price, quantity, is_active, image_url, discontinued FROM products WHERE is_active = TRUE")
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Unable to fetch products"})
		log.Println("Error fetching products:", err)
		return
	}
	defer rows.Close()

	var products []Product

	for rows.Next() {
		var p Product
		if err := rows.Scan(&p.ID, &p.Name, &p.Description, &p.Price, &p.Quantity, &p.IsActive, &p.ImageURL, &p.Discontinued); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Unable to read product data"})
			log.Println("Error reading product data:", err)
			return
		}

		if !strings.HasPrefix(p.ImageURL, "/assets/") {
			p.ImageURL = "/assets/" + p.ImageURL
		}

		products = append(products, p)
	}

	c.JSON(http.StatusOK, products)
}

func updateProductHandler(c *gin.Context) {
	var req Product
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid product data"})
		return
	}

	query := `
        UPDATE products
        SET name = ?, description = ?, price = ?, quantity = ?, discontinued = ?
        WHERE id = ?
    `
	_, err := db.Exec(query, req.Name, req.Description, req.Price, req.Quantity, req.Discontinued, req.ID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Unable to update product"})
		log.Println("Error updating product:", err)
		return
	}

	c.JSON(http.StatusOK, req)
}

func createProductHandler(c *gin.Context) {
	var req Product
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid product data"})
		return
	}

	if !strings.HasPrefix(req.ImageURL, "/assets/") {
		req.ImageURL = "/assets/" + req.ImageURL
	}

	query := `
        INSERT INTO products (name, description, price, quantity, is_active, discontinued, image_url)
        VALUES (?, ?, ?, ?, ?, ?, ?)
    `
	result, err := db.Exec(query, req.Name, req.Description, req.Price, req.Quantity, req.IsActive, req.Discontinued, req.ImageURL)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Unable to create product"})
		log.Println("Error creating product:", err)
		return
	}

	productID, err := result.LastInsertId()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Unable to fetch product ID"})
		log.Println("Error fetching product ID:", err)
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"id":           productID,
		"name":         req.Name,
		"description":  req.Description,
		"price":        req.Price,
		"quantity":     req.Quantity,
		"is_active":    req.IsActive,
		"image_url":    req.ImageURL,
		"discontinued": req.Discontinued,
	})
}

// ----- New handlers for orders and discounts -----

func getOrdersHandler(c *gin.Context) {
	rows, err := db.Query("SELECT id, customer_name, total_price, status, created_at FROM orders")
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Unable to fetch orders"})
		return
	}
	defer rows.Close()

	var orders []Order

	for rows.Next() {
		var o Order
		var createdAt string
		if err := rows.Scan(&o.ID, &o.CustomerName, &o.Total, &o.Status, &createdAt); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Error scanning orders"})
			return
		}
		o.Date = createdAt

		itemRows, err := db.Query(`
            SELECT oi.product_id, p.name, oi.quantity, oi.price_at_purchase
            FROM order_items oi
            JOIN products p ON oi.product_id = p.id
            WHERE oi.order_id = ?`, o.ID)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Unable to fetch order items"})
			return
		}

		var items []OrderItem
		for itemRows.Next() {
			var item OrderItem
			if err := itemRows.Scan(&item.ProductID, &item.ProductName, &item.Quantity, &item.Price); err != nil {
				itemRows.Close()
				c.JSON(http.StatusInternalServerError, gin.H{"error": "Error scanning order items"})
				return
			}
			items = append(items, item)
		}
		itemRows.Close()

		o.Items = items

		orders = append(orders, o)
	}

	c.JSON(http.StatusOK, orders)
}

func getDiscountsHandler(c *gin.Context) {
	rows, err := db.Query("SELECT code, discount_percent FROM discounts WHERE CURDATE() BETWEEN start_date AND end_date")
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Unable to fetch discounts"})
		return
	}
	defer rows.Close()

	var discounts []Discount
	for rows.Next() {
		var d Discount
		if err := rows.Scan(&d.Code, &d.Amount); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Error scanning discounts"})
			return
		}
		discounts = append(discounts, d)
	}

	c.JSON(http.StatusOK, discounts)
}

func executeOrderHandler(c *gin.Context) {
	id := c.Param("id")

	result, err := db.Exec("UPDATE orders SET status = 'executed', executed_at = NOW() WHERE id = ? AND status = 'placed'", id)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Unable to execute order"})
		return
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Unable to check update result"})
		return
	}

	if rowsAffected == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Order not found or already executed"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Order executed successfully"})
}

// -------------------------------------------

func main() {
	r := gin.Default()

	r.Use(cors.Default())

	r.Static("/assets", "./assets")

	r.POST("/login", loginHandler)

	r.GET("/products", getProductsHandler)
	r.PUT("/products/:id", updateProductHandler)
	r.POST("/products", createProductHandler)

	// Added routes for orders and discounts
	r.GET("/orders", getOrdersHandler)
	r.GET("/discounts", getDiscountsHandler)
	r.POST("/orders/:id/execute", executeOrderHandler)

	err := r.Run(":8080")
	if err != nil {
		log.Fatal("Error starting server:", err)
	}
}
